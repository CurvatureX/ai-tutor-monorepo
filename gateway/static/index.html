<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI English Speaking Practice - Gateway</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .header p {
            color: #666;
            font-size: 16px;
        }
        .debug-info {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 12px;
        }
        .timing-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .timing-card {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .timing-card.active {
            background: #fff3cd;
            border-color: #ffeaa7;
        }
        .timing-card.completed {
            background: #d4edda;
            border-color: #c3e6cb;
        }
        .timing-card.error {
            background: #f8d7da;
            border-color: #f5c6cb;
        }
        .timing-label {
            font-weight: 600;
            color: #495057;
            margin-bottom: 5px;
        }
        .timing-value {
            font-size: 18px;
            font-weight: 700;
            color: #007AFF;
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
        }
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background: #007AFF;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background: #0056CC;
        }
        .btn-danger {
            background: #FF3B30;
            color: white;
        }
        .btn-danger:hover:not(:disabled) {
            background: #D70015;
        }
        .btn-secondary {
            background: #F2F2F7;
            color: #333;
        }
        .btn-secondary:hover:not(:disabled) {
            background: #E5E5EA;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: 500;
        }
        .status.connected {
            background: #D1F2EB;
            color: #00875A;
        }
        .status.disconnected {
            background: #FFEBE6;
            color: #DE350B;
        }
        .status.recording {
            background: #FFF4E6;
            color: #FF8B00;
        }
        .chat {
            margin: 30px 0;
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #E5E5EA;
            border-radius: 8px;
            padding: 20px;
            background: #FAFAFA;
        }
        .message {
            margin: 15px 0;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
            position: relative;
        }
        .message.user {
            background: #007AFF;
            color: white;
            margin-left: auto;
        }
        .message.ai {
            background: white;
            border: 1px solid #E5E5EA;
            color: #333;
        }
        .message.system {
            background: #F2F2F7;
            color: #666;
            text-align: center;
            margin: 10px auto;
            font-style: italic;
        }
        .message .timestamp {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 5px;
        }
        .message .confidence {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
        .message .timing {
            font-size: 11px;
            color: #007AFF;
            margin-top: 5px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
        }
        .recording-indicator {
            display: none;
            text-align: center;
            margin: 20px 0;
        }
        .recording-indicator.active {
            display: block;
        }
        .pulse {
            width: 20px;
            height: 20px;
            background: #FF3B30;
            border-radius: 50%;
            display: inline-block;
            animation: pulse 1s infinite;
            margin-right: 10px;
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        .audio-player {
            margin: 10px 0;
            width: 100%;
        }
        .error {
            background: #FFEBE6;
            color: #DE350B;
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
        }
        .module-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        .stat-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #007AFF;
        }
        .stat-label {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
        .message.ise {
            color: #6f42c1;
        }
        .score-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 20px;
            margin: 10px 0;
            color: white;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
        }
        .score-header {
            text-align: center;
            margin-bottom: 20px;
        }
        .overall-score {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .score-subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }
        .detailed-scores {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .score-item {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .score-item h4 {
            margin: 0 0 10px 0;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }
        .score-value {
            font-size: 2em;
            font-weight: bold;
            margin: 5px 0;
        }
        .score-bar {
            background: rgba(255, 255, 255, 0.2);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 10px;
        }
        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3);
            border-radius: 3px;
            transition: width 0.5s ease;
        }
        .word-scores {
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
        }
        .word-scores h4 {
            margin: 0 0 10px 0;
            text-align: center;
        }
        .word-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }
        .word-item {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: 500;
            transition: transform 0.2s ease;
        }
        .word-item:hover {
            transform: scale(1.05);
        }
        .word-correct {
            background: rgba(72, 219, 251, 0.3);
            color: #48dbfb;
            border: 1px solid rgba(72, 219, 251, 0.5);
        }
        .word-incorrect {
            background: rgba(255, 107, 107, 0.3);
            color: #ff6b6b;
            border: 1px solid rgba(255, 107, 107, 0.5);
        }
        .reference-text {
            margin-top: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        .reference-text h4 {
            margin: 0 0 10px 0;
            opacity: 0.8;
        }
        .reference-content {
            font-size: 1.1em;
            font-style: italic;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 AI English Speaking Practice - Gateway</h1>
            <p>Practice your English conversation skills with AI assistance and debug timing</p>
        </div>

        <div class="debug-info">
            <strong>Debug Info:</strong> Session ID: <span id="sessionId"></span> | WebSocket: <span id="wsStatus">Disconnected</span>
        </div>

        <div class="timing-info">
            <div class="timing-card" id="asrTiming">
                <div class="timing-label">ASR Processing</div>
                <div class="timing-value" id="asrTime">-</div>
            </div>
            <div class="timing-card" id="llmTiming">
                <div class="timing-label">LLM Response</div>
                <div class="timing-value" id="llmTime">-</div>
            </div>
            <div class="timing-card" id="ttsTiming">
                <div class="timing-label">TTS Generation</div>
                <div class="timing-value" id="ttsTime">-</div>
            </div>
            <div class="timing-card" id="iseTiming">
                <div class="timing-label">ISE Evaluation</div>
                <div class="timing-value" id="iseTime">-</div>
            </div>
            <div class="timing-card" id="totalTiming">
                <div class="timing-label">Total Pipeline</div>
                <div class="timing-value" id="totalTime">-</div>
            </div>
        </div>

        <div class="module-stats">
            <div class="stat-item">
                <div class="stat-value" id="totalRequests">0</div>
                <div class="stat-label">Total Requests</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="avgResponse">-</div>
                <div class="stat-label">Avg Response (ms)</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="errorCount">0</div>
                <div class="stat-label">Errors</div>
            </div>
        </div>
        
        <div id="status" class="status disconnected">
            Disconnected - Click Connect to start
        </div>
        
        <div class="controls">
            <button id="connectBtn" class="btn btn-primary">Connect</button>
            <button id="disconnectBtn" class="btn btn-secondary" disabled>Disconnect</button>
            <button id="recordBtn" class="btn btn-primary" disabled>🎤 Start Recording</button>
            <button id="stopBtn" class="btn btn-danger" disabled>⏹️ Stop Recording</button>
            <button id="clearBtn" class="btn btn-secondary">Clear Chat</button>
        </div>

        <div id="recordingIndicator" class="recording-indicator">
            <div class="pulse"></div>
            <span>Recording... Speak now!</span>
        </div>
        
        <div id="chat" class="chat">
            <div class="message system">
                Welcome! Connect to the gateway server and start practicing your English conversation skills.
                This interface shows timing information for each processing step to help with debugging.
            </div>
        </div>
    </div>

    <script>
        class GatewayVoicePracticeApp {
            constructor() {
                this.ws = null;
                this.mediaRecorder = null;
                this.audioStream = null;
                this.isConnected = false;
                this.isRecording = false;
                this.sessionId = this.generateSessionId();
                this.stats = {
                    totalRequests: 0,
                    totalResponseTime: 0,
                    errors: 0
                };
                this.currentRequest = {
                    startTime: null,
                    asrStartTime: null,
                    llmStartTime: null,
                    ttsStartTime: null,
                    iseStartTime: null
                };
                
                this.initializeElements();
                this.bindEvents();
                this.updateSessionInfo();
            }

            initializeElements() {
                this.statusEl = document.getElementById('status');
                this.chatEl = document.getElementById('chat');
                this.connectBtn = document.getElementById('connectBtn');
                this.disconnectBtn = document.getElementById('disconnectBtn');
                this.recordBtn = document.getElementById('recordBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.clearBtn = document.getElementById('clearBtn');
                this.recordingIndicator = document.getElementById('recordingIndicator');
                
                // Timing elements
                this.asrTimingEl = document.getElementById('asrTiming');
                this.llmTimingEl = document.getElementById('llmTiming');
                this.ttsTimingEl = document.getElementById('ttsTiming');
                this.iseTimingEl = document.getElementById('iseTiming');
                this.totalTimingEl = document.getElementById('totalTiming');
                
                this.asrTimeEl = document.getElementById('asrTime');
                this.llmTimeEl = document.getElementById('llmTime');
                this.ttsTimeEl = document.getElementById('ttsTime');
                this.iseTimeEl = document.getElementById('iseTime');
                this.totalTimeEl = document.getElementById('totalTime');
                
                // Stats elements
                this.totalRequestsEl = document.getElementById('totalRequests');
                this.avgResponseEl = document.getElementById('avgResponse');
                this.errorCountEl = document.getElementById('errorCount');
            }

            bindEvents() {
                this.connectBtn.addEventListener('click', () => this.connect());
                this.disconnectBtn.addEventListener('click', () => this.disconnect());
                this.recordBtn.addEventListener('click', () => this.startRecording());
                this.stopBtn.addEventListener('click', () => this.stopRecording());
                this.clearBtn.addEventListener('click', () => this.clearChat());
            }

            generateSessionId() {
                return 'gateway_session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            updateSessionInfo() {
                document.getElementById('sessionId').textContent = this.sessionId;
                document.getElementById('wsStatus').textContent = this.isConnected ? 'Connected' : 'Disconnected';
            }

            updateStatus(message, className) {
                this.statusEl.textContent = message;
                this.statusEl.className = `status ${className}`;
            }

            updateStats() {
                this.totalRequestsEl.textContent = this.stats.totalRequests;
                this.errorCountEl.textContent = this.stats.errors;
                
                if (this.stats.totalRequests > 0) {
                    const avgTime = Math.round(this.stats.totalResponseTime / this.stats.totalRequests);
                    this.avgResponseEl.textContent = avgTime + 'ms';
                } else {
                    this.avgResponseEl.textContent = '-';
                    try {
                        const data = JSON.parse(event.data);
                        if (data.data && typeof data.data === 'object') {
                            if (data.data.type === 'asr_result') {
                                addMessage('ASR: ' + data.data.text + ' (confidence: ' + data.data.confidence + ')', 'asr');
                            } else if (data.data.type === 'llm_response') {
                                addMessage('LLM: ' + data.data.text, 'llm');
                            } else if (data.data.type === 'tts_ready') {
                                addMessage('TTS audio ready (format: ' + data.data.format + ')', 'tts');
                            } else if (data.data.type === 'ise_result') {
                                displayISEResult(data.data);
                            }
                        } else {
                            addMessage('Gateway: ' + (data.data || JSON.stringify(data)));
                        }
                    } catch (e) {
                        addMessage('Gateway: ' + event.data);
                    }
                }
            }

            resetTimingDisplay() {
                this.asrTimeEl.textContent = '-';
                this.llmTimeEl.textContent = '-';
                this.ttsTimeEl.textContent = '-';
                this.iseTimeEl.textContent = '-';
                this.totalTimeEl.textContent = '-';
                
                [this.asrTimingEl, this.llmTimingEl, this.ttsTimingEl, this.iseTimingEl, this.totalTimingEl].forEach(el => {
                    el.classList.remove('active', 'completed', 'error');
                });
            }

            updateTimingDisplay(module, time, status = 'completed') {
                const timeEl = document.getElementById(module + 'Time');
                const cardEl = document.getElementById(module + 'Timing');
                
                if (timeEl) {
                    timeEl.textContent = time + 'ms';
                }
                
                if (cardEl) {
                    cardEl.classList.remove('active', 'completed', 'error');
                    cardEl.classList.add(status);
                }
            }

            setModuleActive(module) {
                const cardEl = document.getElementById(module + 'Timing');
                if (cardEl) {
                    cardEl.classList.remove('completed', 'error');
                    cardEl.classList.add('active');
                }
            }

            addMessage(text, type = 'system', metadata = {}) {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${type}`;
                
                let content = `<div>${text}</div>`;
                
                if (metadata.confidence) {
                    content += `<div class="confidence">Confidence: ${(metadata.confidence * 100).toFixed(1)}%</div>`;
                }
                
                if (metadata.timing) {
                    content += `<div class="timing">${metadata.timing}</div>`;
                }
                
                content += `<div class="timestamp">${new Date().toLocaleTimeString()}</div>`;
                messageEl.innerHTML = content;
                
                this.chatEl.appendChild(messageEl);
                this.chatEl.scrollTop = this.chatEl.scrollHeight;
            }

            addAudioMessage(audioData, type = 'ai', metadata = {}) {
                const messageEl = document.createElement('div');
                messageEl.className = `message ${type}`;
                
                const audio = document.createElement('audio');
                audio.controls = true;
                audio.className = 'audio-player';
                
                const blob = new Blob([audioData], { type: 'audio/mp3' });
                audio.src = URL.createObjectURL(blob);
                
                messageEl.appendChild(audio);
                
                if (metadata.timing) {
                    const timingDiv = document.createElement('div');
                    timingDiv.className = 'timing';
                    timingDiv.textContent = metadata.timing;
                    messageEl.appendChild(timingDiv);
                }
                
                const timestamp = document.createElement('div');
                timestamp.className = 'timestamp';
                timestamp.textContent = new Date().toLocaleTimeString();
                messageEl.appendChild(timestamp);
                
                this.chatEl.appendChild(messageEl);
                this.chatEl.scrollTop = this.chatEl.scrollHeight;
                
                audio.play().catch(e => console.log('Auto-play failed:', e));
            }

            showError(message) {
                const errorEl = document.createElement('div');
                errorEl.className = 'error';
                errorEl.textContent = message;
                this.chatEl.appendChild(errorEl);
                this.chatEl.scrollTop = this.chatEl.scrollHeight;
                
                this.stats.errors++;
                this.updateStats();
                
                setTimeout(() => {
                    if (errorEl.parentNode) {
                        errorEl.parentNode.removeChild(errorEl);
                    }
                }, 5000);
            }

            clearChat() {
                this.chatEl.innerHTML = '<div class="message system">Chat cleared. Ready for new conversation.</div>';
                this.resetTimingDisplay();
            }

            async connect() {
                try {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws?session_id=${this.sessionId}`;
                    
                    this.updateStatus('Connecting...', 'disconnected');
                    
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        this.isConnected = true;
                        this.updateStatus('Connected - Ready to practice!', 'connected');
                        this.connectBtn.disabled = true;
                        this.disconnectBtn.disabled = false;
                        this.recordBtn.disabled = false;
                        this.updateSessionInfo();
                        this.addMessage('Connected to Gateway! You can now start recording your voice.', 'system');
                    };
                    
                    this.ws.onmessage = (event) => {
                        if (event.data instanceof Blob) {
                            this.handleAudioMessage(event.data);
                        } else {
                            this.handleTextMessage(JSON.parse(event.data));
                        }
                    };
                    
                    this.ws.onclose = () => {
                        this.isConnected = false;
                        this.updateStatus('Disconnected', 'disconnected');
                        this.connectBtn.disabled = false;
                        this.disconnectBtn.disabled = true;
                        this.recordBtn.disabled = true;
                        this.stopBtn.disabled = true;
                        this.updateSessionInfo();
                        if (this.isRecording) {
                            this.stopRecording();
                        }
                        this.addMessage('Gateway connection closed', 'system');
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        let errorMessage = 'Connection error';
                        
                        // Try to get more specific error information
                        if (error.message) {
                            errorMessage = error.message;
                        } else if (error.code) {
                            errorMessage = `Connection failed (Code: ${error.code})`;
                        } else if (this.ws.readyState === WebSocket.CLOSED) {
                            errorMessage = 'Connection closed unexpectedly';
                        } else if (this.ws.readyState === WebSocket.CLOSING) {
                            errorMessage = 'Connection is closing';
                        }
                        
                        this.showError('WebSocket error: ' + errorMessage);
                    };
                    
                } catch (error) {
                    console.error('Connection error:', error);
                    const errorMessage = error.message || error.toString() || 'Unknown connection error';
                    this.showError('Failed to connect: ' + errorMessage);
                }
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                }
                if (this.isRecording) {
                    this.stopRecording();
                }
            }

            handleTextMessage(message) {
                console.log('Received message:', message);
                
                switch (message.type) {
                    case 'text':
                        if (typeof message.data === 'object') {
                            switch (message.data.type) {
                                case 'asr_result':
                                    if (message.data.text) {
                                        const asrTime = Date.now() - this.currentRequest.asrStartTime;
                                        this.updateTimingDisplay('asr', asrTime);
                                        
                                        this.addMessage(message.data.text, 'user', {
                                            timing: `ASR: ${asrTime}ms`
                                        });
                                        
                                        // Start ISE timing (ISE processing begins after ASR)
                                        this.currentRequest.iseStartTime = Date.now();
                                        this.setModuleActive('ise');
                                        
                                        this.currentRequest.llmStartTime = Date.now();
                                        this.setModuleActive('llm');
                                    }
                                    break;
                                case 'llm_response':
                                    const llmTime = Date.now() - this.currentRequest.llmStartTime;
                                    this.updateTimingDisplay('llm', llmTime);
                                    
                                    this.addMessage(message.data.text, 'ai', {
                                        timing: `LLM: ${llmTime}ms`
                                    });
                                    
                                    this.currentRequest.ttsStartTime = Date.now();
                                    this.setModuleActive('tts');
                                    break;
                                case 'tts_ready':
                                    // Calculate and display TTS timing
                                    if (this.currentRequest.ttsStartTime) {
                                        const ttsTime = Date.now() - this.currentRequest.ttsStartTime;
                                        this.updateTimingDisplay('tts', ttsTime);
                                        console.log('TTS completed in:', ttsTime, 'ms');
                                    } else {
                                        console.warn('TTS start time not set, cannot calculate timing');
                                    }
                                    
                                    const totalTime = Date.now() - this.currentRequest.startTime;
                                    this.updateTimingDisplay('total', totalTime);
                                    
                                    this.stats.totalRequests++;
                                    this.stats.totalResponseTime += totalTime;
                                    this.updateStats();
                                    
                                    console.log('TTS audio ready, format:', message.data.format);
                                    break;
                                case 'ise_result':
                                    console.log('Received ISE result:', message.data);
                                    
                                    // Calculate and display ISE timing
                                    if (this.currentRequest.iseStartTime) {
                                        const iseTime = Date.now() - this.currentRequest.iseStartTime;
                                        this.updateTimingDisplay('ise', iseTime);
                                    }
                                    
                                    this.updateLastUserMessageWithScore(message.data);
                                    break;
                            }
                        } else {
                            this.addMessage(message.data, 'ai');
                        }
                        break;
                    case 'error':
                        this.showError(message.data);
                        [this.asrTimingEl, this.llmTimingEl, this.ttsTimingEl, this.iseTimingEl, this.totalTimingEl].forEach(el => {
                            if (el.classList.contains('active')) {
                                el.classList.remove('active');
                                el.classList.add('error');
                            }
                        });
                        break;
                    case 'status':
                        // Only handle non-ISE status messages
                        if (message.data.message && !message.data.message.includes('Voice scoring')) {
                            this.addMessage(message.data.message, 'system');
                        }
                        break;
                }
            }

            handleAudioMessage(audioBlob) {
                console.log('Received audio data:', audioBlob.size, 'bytes');
                const totalTime = Date.now() - this.currentRequest.startTime;
                this.addAudioMessage(audioBlob, 'ai', {
                    timing: `Total pipeline: ${totalTime}ms`
                });
            }

            async startRecording() {
                try {
                    this.resetTimingDisplay();
                    this.currentRequest.startTime = Date.now();
                    
                    this.audioStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });

                    let options;
                    if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                        options = {
                            mimeType: 'audio/webm;codecs=opus',
                            audioBitsPerSecond: 64000
                        };
                    } else if (MediaRecorder.isTypeSupported('audio/webm')) {
                        options = {
                            mimeType: 'audio/webm',
                            audioBitsPerSecond: 64000
                        };
                    } else {
                        options = {};
                    }

                    this.mediaRecorder = new MediaRecorder(this.audioStream, options);
                    this.audioChunks = [];
                    
                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            this.audioChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = () => {
                        if (this.audioChunks.length > 0) {
                            const mimeType = options.mimeType || 'audio/webm';
                            const completeBlob = new Blob(this.audioChunks, { type: mimeType });
                            
                            if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                                this.ws.send(completeBlob);
                                this.currentRequest.asrStartTime = Date.now();
                                this.setModuleActive('asr');
                            }
                        }
                    };

                    this.mediaRecorder.start(200);
                    this.isRecording = true;
                    
                    this.sendControlMessage('start_recording');
                    
                    this.updateStatus('Recording... Speak now!', 'recording');
                    this.recordBtn.disabled = true;
                    this.stopBtn.disabled = false;
                    this.recordingIndicator.classList.add('active');
                    
                } catch (error) {
                    console.error('Recording error:', error);
                    const errorMessage = error.message || error.toString() || 'Unknown recording error';
                    this.showError('Failed to start recording: ' + errorMessage);
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    
                    this.sendControlMessage('stop_recording');
                    
                    this.updateStatus('Connected - Ready to practice!', 'connected');
                    this.recordBtn.disabled = false;
                    this.stopBtn.disabled = true;
                    this.recordingIndicator.classList.remove('active');
                }
                
                if (this.audioStream) {
                    this.audioStream.getTracks().forEach(track => track.stop());
                    this.audioStream = null;
                }
            }

            sendControlMessage(action) {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    const message = {
                        type: 'control',
                        data: { action: action },
                        session: this.sessionId
                    };
                    this.ws.send(JSON.stringify(message));
                }
            }

            updateLastUserMessageWithScore(iseData) {
                // Find the last user message
                const userMessages = this.chatEl.querySelectorAll('.message.user');
                if (userMessages.length === 0) return;
                
                const lastUserMessage = userMessages[userMessages.length - 1];
                
                // Get the original text content (first div contains the main message)
                const messageContent = lastUserMessage.querySelector('div');
                if (!messageContent) return;
                
                let originalText = messageContent.textContent.trim();
                
                // Remove timing info if present (like "ASR: 5113ms")
                originalText = originalText.replace(/ASR:\s*\d+ms/g, '').trim();
                
                // If we have word scores, highlight words with score < 4.5
                if (iseData.word_scores && iseData.word_scores.length > 0) {
                    let processedText = originalText;
                    
                    // Create a map of words that need highlighting (< 4.5)
                    const wordsToHighlight = iseData.word_scores.filter(word => word.score < 4.5);
                    
                    if (wordsToHighlight.length > 0) {
                        // Sort words by length (longest first) to avoid partial replacements
                        wordsToHighlight.sort((a, b) => b.word.length - a.word.length);
                        
                        // Replace each word with highlighted version based on score
                        wordsToHighlight.forEach(wordData => {
                            const word = wordData.word;
                            const score = wordData.score.toFixed(1);
                            
                            // Determine color and style based on score
                            let color, backgroundColor, title;
                            if (score < 4.0) {
                                // Red for scores < 4.0 (needs improvement)
                                color = '#ff6b6b';
                                backgroundColor = 'linear-gradient(180deg, transparent 0%, transparent 65%, rgba(255, 107, 107, 0.15) 65%, rgba(255, 107, 107, 0.25) 100%)';
                                title = '发音需要改进';
                            } else {
                                // Yellow for scores 4.0-4.4 (average)
                                color = '#f39c12';
                                backgroundColor = 'linear-gradient(180deg, transparent 0%, transparent 65%, rgba(243, 156, 18, 0.15) 65%, rgba(243, 156, 18, 0.25) 100%)';
                                title = '发音一般，可以提升';
                            }
                            
                            // Create case-insensitive regex for word boundaries
                            const regex = new RegExp(`\\b${word}\\b`, 'gi');
                            
                            // Replace with elegant highlighted version
                            const highlightedWord = `<span style="
                                position: relative;
                                color: ${color}; 
                                font-weight: 500;
                                background: ${backgroundColor};
                                border-radius: 2px;
                                padding: 1px 2px;
                            " title="${title}: ${score}/5.0">${word}<span style="
                                font-size: 0.65em; 
                                color: ${color}; 
                                font-weight: 400;
                                margin-left: 2px;
                                opacity: 0.8;
                            ">${score}</span></span>`;
                            
                            processedText = processedText.replace(regex, highlightedWord);
                        });
                        
                        // Update the message content with highlighted text
                        messageContent.innerHTML = processedText;
                    }
                }
                
                // Add overall score summary at the end (compact version)
                const overallScore = Math.round((iseData.overall_score || 0) * 10) / 10;
                const accuracyScore = Math.round((iseData.accuracy_score || 0) * 10) / 10;
                const fluencyScore = Math.round((iseData.fluency_score || 0) * 10) / 10;
                const completenessScore = Math.round((iseData.completeness_score || 0) * 10) / 10;
                
                const getScoreColor = (score) => {
                    if (score >= 4.5) return '#48dbfb';  // 优秀
                    if (score >= 4.0) return '#feca57';  // 良好
                    if (score >= 3.5) return '#ff9ff3';  // 一般
                    return '#ff6b6b';                    // 需要改进
                };
                
                // Add compact overall score
                const scoreHTML = `
                    <div style="
                        margin-top: 8px; 
                        padding: 6px 10px; 
                        background: rgba(255, 255, 255, 0.95); 
                        border-radius: 8px; 
                        border-left: 3px solid ${getScoreColor(overallScore)};
                        font-size: 0.8em;
                        color: #555;
                        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
                        line-height: 1.3;
                    ">
                        <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                            <span style="color: ${getScoreColor(overallScore)}; font-weight: 600;">
                                🎯总分 ${overallScore}
                            </span>
                            <div style="display: flex; gap: 8px; font-size: 0.9em; color: #666;">
                                <span>📝准确性 <span style="color: ${getScoreColor(accuracyScore)}; font-weight: 500;">${accuracyScore}</span></span>
                                <span>🗣️流利度 <span style="color: ${getScoreColor(fluencyScore)}; font-weight: 500;">${fluencyScore}</span></span>
                                <span>✅完整度 <span style="color: ${getScoreColor(completenessScore)}; font-weight: 500;">${completenessScore}</span></span>
                            </div>
                        </div>
                    </div>
                `;
                
                lastUserMessage.insertAdjacentHTML('beforeend', scoreHTML);
                
                // Scroll to show the updated message
                this.chatEl.scrollTop = this.chatEl.scrollHeight;
            }

        }

        document.addEventListener('DOMContentLoaded', () => {
            new GatewayVoicePracticeApp();
        });
        function sendControlMessage(action) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const message = {
                    type: 'control',
                    data: {
                        action: action
                    },
                    session: sessionId
                };
                ws.send(JSON.stringify(message));
            }
        }

        function sendAudioData(audioBlob) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                addMessage('Sending audio data (' + audioBlob.size + ' bytes)...');
                ws.send(audioBlob);
            }
        }

        function clearMessages() {
            document.getElementById('messages').innerHTML = '';
        }



        // Auto-connect on page load
        window.onload = function() {
            connect();
        };
    </script>
</body>
</html>