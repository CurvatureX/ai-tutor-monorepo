// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: speech/speech.proto

package speechv1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ControlAction int32

const (
	ControlAction_CONTROL_ACTION_UNSPECIFIED     ControlAction = 0
	ControlAction_CONTROL_ACTION_START_RECORDING ControlAction = 1
	ControlAction_CONTROL_ACTION_STOP_RECORDING  ControlAction = 2
	ControlAction_CONTROL_ACTION_END_SESSION     ControlAction = 3
	ControlAction_CONTROL_ACTION_PAUSE_SESSION   ControlAction = 4
	ControlAction_CONTROL_ACTION_RESUME_SESSION  ControlAction = 5
)

// Enum value maps for ControlAction.
var (
	ControlAction_name = map[int32]string{
		0: "CONTROL_ACTION_UNSPECIFIED",
		1: "CONTROL_ACTION_START_RECORDING",
		2: "CONTROL_ACTION_STOP_RECORDING",
		3: "CONTROL_ACTION_END_SESSION",
		4: "CONTROL_ACTION_PAUSE_SESSION",
		5: "CONTROL_ACTION_RESUME_SESSION",
	}
	ControlAction_value = map[string]int32{
		"CONTROL_ACTION_UNSPECIFIED":     0,
		"CONTROL_ACTION_START_RECORDING": 1,
		"CONTROL_ACTION_STOP_RECORDING":  2,
		"CONTROL_ACTION_END_SESSION":     3,
		"CONTROL_ACTION_PAUSE_SESSION":   4,
		"CONTROL_ACTION_RESUME_SESSION":  5,
	}
)

func (x ControlAction) Enum() *ControlAction {
	p := new(ControlAction)
	*p = x
	return p
}

func (x ControlAction) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ControlAction) Descriptor() protoreflect.EnumDescriptor {
	return file_speech_speech_proto_enumTypes[0].Descriptor()
}

func (ControlAction) Type() protoreflect.EnumType {
	return &file_speech_speech_proto_enumTypes[0]
}

func (x ControlAction) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ControlAction.Descriptor instead.
func (ControlAction) EnumDescriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{0}
}

type LLMResultType int32

const (
	LLMResultType_LLM_RESULT_TYPE_UNSPECIFIED LLMResultType = 0
	LLMResultType_LLM_RESULT_TYPE_RESPONSE    LLMResultType = 1 // Regular conversation response
	LLMResultType_LLM_RESULT_TYPE_CORRECTION  LLMResultType = 2 // Grammar/pronunciation correction
	LLMResultType_LLM_RESULT_TYPE_SUGGESTION  LLMResultType = 3 // Learning suggestion
	LLMResultType_LLM_RESULT_TYPE_STARTER     LLMResultType = 4 // Conversation starter
)

// Enum value maps for LLMResultType.
var (
	LLMResultType_name = map[int32]string{
		0: "LLM_RESULT_TYPE_UNSPECIFIED",
		1: "LLM_RESULT_TYPE_RESPONSE",
		2: "LLM_RESULT_TYPE_CORRECTION",
		3: "LLM_RESULT_TYPE_SUGGESTION",
		4: "LLM_RESULT_TYPE_STARTER",
	}
	LLMResultType_value = map[string]int32{
		"LLM_RESULT_TYPE_UNSPECIFIED": 0,
		"LLM_RESULT_TYPE_RESPONSE":    1,
		"LLM_RESULT_TYPE_CORRECTION":  2,
		"LLM_RESULT_TYPE_SUGGESTION":  3,
		"LLM_RESULT_TYPE_STARTER":     4,
	}
)

func (x LLMResultType) Enum() *LLMResultType {
	p := new(LLMResultType)
	*p = x
	return p
}

func (x LLMResultType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LLMResultType) Descriptor() protoreflect.EnumDescriptor {
	return file_speech_speech_proto_enumTypes[1].Descriptor()
}

func (LLMResultType) Type() protoreflect.EnumType {
	return &file_speech_speech_proto_enumTypes[1]
}

func (x LLMResultType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LLMResultType.Descriptor instead.
func (LLMResultType) EnumDescriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{1}
}

type ErrorCode int32

const (
	ErrorCode_ERROR_CODE_UNSPECIFIED             ErrorCode = 0
	ErrorCode_ERROR_CODE_INVALID_REQUEST         ErrorCode = 1
	ErrorCode_ERROR_CODE_AUDIO_PROCESSING_FAILED ErrorCode = 2
	ErrorCode_ERROR_CODE_ASR_FAILED              ErrorCode = 3
	ErrorCode_ERROR_CODE_LLM_FAILED              ErrorCode = 4
	ErrorCode_ERROR_CODE_TTS_FAILED              ErrorCode = 5
	ErrorCode_ERROR_CODE_SESSION_NOT_FOUND       ErrorCode = 6
	ErrorCode_ERROR_CODE_SERVICE_UNAVAILABLE     ErrorCode = 7
	ErrorCode_ERROR_CODE_RATE_LIMITED            ErrorCode = 8
)

// Enum value maps for ErrorCode.
var (
	ErrorCode_name = map[int32]string{
		0: "ERROR_CODE_UNSPECIFIED",
		1: "ERROR_CODE_INVALID_REQUEST",
		2: "ERROR_CODE_AUDIO_PROCESSING_FAILED",
		3: "ERROR_CODE_ASR_FAILED",
		4: "ERROR_CODE_LLM_FAILED",
		5: "ERROR_CODE_TTS_FAILED",
		6: "ERROR_CODE_SESSION_NOT_FOUND",
		7: "ERROR_CODE_SERVICE_UNAVAILABLE",
		8: "ERROR_CODE_RATE_LIMITED",
	}
	ErrorCode_value = map[string]int32{
		"ERROR_CODE_UNSPECIFIED":             0,
		"ERROR_CODE_INVALID_REQUEST":         1,
		"ERROR_CODE_AUDIO_PROCESSING_FAILED": 2,
		"ERROR_CODE_ASR_FAILED":              3,
		"ERROR_CODE_LLM_FAILED":              4,
		"ERROR_CODE_TTS_FAILED":              5,
		"ERROR_CODE_SESSION_NOT_FOUND":       6,
		"ERROR_CODE_SERVICE_UNAVAILABLE":     7,
		"ERROR_CODE_RATE_LIMITED":            8,
	}
)

func (x ErrorCode) Enum() *ErrorCode {
	p := new(ErrorCode)
	*p = x
	return p
}

func (x ErrorCode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ErrorCode) Descriptor() protoreflect.EnumDescriptor {
	return file_speech_speech_proto_enumTypes[2].Descriptor()
}

func (ErrorCode) Type() protoreflect.EnumType {
	return &file_speech_speech_proto_enumTypes[2]
}

func (x ErrorCode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ErrorCode.Descriptor instead.
func (ErrorCode) EnumDescriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{2}
}

type ProcessingStatus int32

const (
	ProcessingStatus_PROCESSING_STATUS_UNSPECIFIED ProcessingStatus = 0
	ProcessingStatus_PROCESSING_STATUS_STARTED     ProcessingStatus = 1
	ProcessingStatus_PROCESSING_STATUS_PROCESSING  ProcessingStatus = 2
	ProcessingStatus_PROCESSING_STATUS_COMPLETED   ProcessingStatus = 3
	ProcessingStatus_PROCESSING_STATUS_FAILED      ProcessingStatus = 4
)

// Enum value maps for ProcessingStatus.
var (
	ProcessingStatus_name = map[int32]string{
		0: "PROCESSING_STATUS_UNSPECIFIED",
		1: "PROCESSING_STATUS_STARTED",
		2: "PROCESSING_STATUS_PROCESSING",
		3: "PROCESSING_STATUS_COMPLETED",
		4: "PROCESSING_STATUS_FAILED",
	}
	ProcessingStatus_value = map[string]int32{
		"PROCESSING_STATUS_UNSPECIFIED": 0,
		"PROCESSING_STATUS_STARTED":     1,
		"PROCESSING_STATUS_PROCESSING":  2,
		"PROCESSING_STATUS_COMPLETED":   3,
		"PROCESSING_STATUS_FAILED":      4,
	}
)

func (x ProcessingStatus) Enum() *ProcessingStatus {
	p := new(ProcessingStatus)
	*p = x
	return p
}

func (x ProcessingStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProcessingStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_speech_speech_proto_enumTypes[3].Descriptor()
}

func (ProcessingStatus) Type() protoreflect.EnumType {
	return &file_speech_speech_proto_enumTypes[3]
}

func (x ProcessingStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProcessingStatus.Descriptor instead.
func (ProcessingStatus) EnumDescriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{3}
}

type HealthStatus int32

const (
	HealthStatus_HEALTH_STATUS_UNSPECIFIED     HealthStatus = 0
	HealthStatus_HEALTH_STATUS_SERVING         HealthStatus = 1
	HealthStatus_HEALTH_STATUS_NOT_SERVING     HealthStatus = 2
	HealthStatus_HEALTH_STATUS_SERVICE_UNKNOWN HealthStatus = 3
)

// Enum value maps for HealthStatus.
var (
	HealthStatus_name = map[int32]string{
		0: "HEALTH_STATUS_UNSPECIFIED",
		1: "HEALTH_STATUS_SERVING",
		2: "HEALTH_STATUS_NOT_SERVING",
		3: "HEALTH_STATUS_SERVICE_UNKNOWN",
	}
	HealthStatus_value = map[string]int32{
		"HEALTH_STATUS_UNSPECIFIED":     0,
		"HEALTH_STATUS_SERVING":         1,
		"HEALTH_STATUS_NOT_SERVING":     2,
		"HEALTH_STATUS_SERVICE_UNKNOWN": 3,
	}
)

func (x HealthStatus) Enum() *HealthStatus {
	p := new(HealthStatus)
	*p = x
	return p
}

func (x HealthStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (HealthStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_speech_speech_proto_enumTypes[4].Descriptor()
}

func (HealthStatus) Type() protoreflect.EnumType {
	return &file_speech_speech_proto_enumTypes[4]
}

func (x HealthStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use HealthStatus.Descriptor instead.
func (HealthStatus) EnumDescriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{4}
}

// VoiceRequest represents incoming requests in the voice conversation stream
type VoiceRequest struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	SessionId string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Timestamp int64                  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// Types that are valid to be assigned to RequestType:
	//
	//	*VoiceRequest_AudioData
	//	*VoiceRequest_Control
	RequestType   isVoiceRequest_RequestType `protobuf_oneof:"request_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VoiceRequest) Reset() {
	*x = VoiceRequest{}
	mi := &file_speech_speech_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VoiceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VoiceRequest) ProtoMessage() {}

func (x *VoiceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VoiceRequest.ProtoReflect.Descriptor instead.
func (*VoiceRequest) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{0}
}

func (x *VoiceRequest) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *VoiceRequest) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *VoiceRequest) GetRequestType() isVoiceRequest_RequestType {
	if x != nil {
		return x.RequestType
	}
	return nil
}

func (x *VoiceRequest) GetAudioData() *AudioData {
	if x != nil {
		if x, ok := x.RequestType.(*VoiceRequest_AudioData); ok {
			return x.AudioData
		}
	}
	return nil
}

func (x *VoiceRequest) GetControl() *ControlMessage {
	if x != nil {
		if x, ok := x.RequestType.(*VoiceRequest_Control); ok {
			return x.Control
		}
	}
	return nil
}

type isVoiceRequest_RequestType interface {
	isVoiceRequest_RequestType()
}

type VoiceRequest_AudioData struct {
	AudioData *AudioData `protobuf:"bytes,3,opt,name=audio_data,json=audioData,proto3,oneof"`
}

type VoiceRequest_Control struct {
	Control *ControlMessage `protobuf:"bytes,4,opt,name=control,proto3,oneof"`
}

func (*VoiceRequest_AudioData) isVoiceRequest_RequestType() {}

func (*VoiceRequest_Control) isVoiceRequest_RequestType() {}

// AudioData contains audio information
type AudioData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Data          []byte                 `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Format        *AudioFormat           `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	Metadata      *AudioMetadata         `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AudioData) Reset() {
	*x = AudioData{}
	mi := &file_speech_speech_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AudioData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioData) ProtoMessage() {}

func (x *AudioData) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioData.ProtoReflect.Descriptor instead.
func (*AudioData) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{1}
}

func (x *AudioData) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *AudioData) GetFormat() *AudioFormat {
	if x != nil {
		return x.Format
	}
	return nil
}

func (x *AudioData) GetMetadata() *AudioMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// AudioFormat specifies audio format details
type AudioFormat struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Codec         string                 `protobuf:"bytes,1,opt,name=codec,proto3" json:"codec,omitempty"`                              // e.g., "webm", "wav", "pcm"
	SampleRate    int32                  `protobuf:"varint,2,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"` // e.g., 16000, 44100
	Channels      int32                  `protobuf:"varint,3,opt,name=channels,proto3" json:"channels,omitempty"`                       // e.g., 1 (mono), 2 (stereo)
	BitDepth      int32                  `protobuf:"varint,4,opt,name=bit_depth,json=bitDepth,proto3" json:"bit_depth,omitempty"`       // e.g., 16, 24
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AudioFormat) Reset() {
	*x = AudioFormat{}
	mi := &file_speech_speech_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AudioFormat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioFormat) ProtoMessage() {}

func (x *AudioFormat) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioFormat.ProtoReflect.Descriptor instead.
func (*AudioFormat) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{2}
}

func (x *AudioFormat) GetCodec() string {
	if x != nil {
		return x.Codec
	}
	return ""
}

func (x *AudioFormat) GetSampleRate() int32 {
	if x != nil {
		return x.SampleRate
	}
	return 0
}

func (x *AudioFormat) GetChannels() int32 {
	if x != nil {
		return x.Channels
	}
	return 0
}

func (x *AudioFormat) GetBitDepth() int32 {
	if x != nil {
		return x.BitDepth
	}
	return 0
}

// AudioMetadata contains additional audio information
type AudioMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	DurationMs    int64                  `protobuf:"varint,1,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	ChunkIndex    int32                  `protobuf:"varint,2,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty"`
	IsFinal       bool                   `protobuf:"varint,3,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AudioMetadata) Reset() {
	*x = AudioMetadata{}
	mi := &file_speech_speech_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AudioMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AudioMetadata) ProtoMessage() {}

func (x *AudioMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AudioMetadata.ProtoReflect.Descriptor instead.
func (*AudioMetadata) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{3}
}

func (x *AudioMetadata) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *AudioMetadata) GetChunkIndex() int32 {
	if x != nil {
		return x.ChunkIndex
	}
	return 0
}

func (x *AudioMetadata) GetIsFinal() bool {
	if x != nil {
		return x.IsFinal
	}
	return false
}

// ControlMessage for session control
type ControlMessage struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Action        ControlAction          `protobuf:"varint,1,opt,name=action,proto3,enum=speech.v1.ControlAction" json:"action,omitempty"`
	Params        map[string]string      `protobuf:"bytes,2,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ControlMessage) Reset() {
	*x = ControlMessage{}
	mi := &file_speech_speech_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ControlMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ControlMessage) ProtoMessage() {}

func (x *ControlMessage) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ControlMessage.ProtoReflect.Descriptor instead.
func (*ControlMessage) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{4}
}

func (x *ControlMessage) GetAction() ControlAction {
	if x != nil {
		return x.Action
	}
	return ControlAction_CONTROL_ACTION_UNSPECIFIED
}

func (x *ControlMessage) GetParams() map[string]string {
	if x != nil {
		return x.Params
	}
	return nil
}

// VoiceResponse represents responses in the voice conversation stream
type VoiceResponse struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	SessionId string                 `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Timestamp int64                  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Status    *ResponseStatus        `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// Types that are valid to be assigned to ResponseType:
	//
	//	*VoiceResponse_AsrResult
	//	*VoiceResponse_LlmResult
	//	*VoiceResponse_TtsResult
	//	*VoiceResponse_IseResult
	//	*VoiceResponse_Error
	//	*VoiceResponse_StatusResult
	ResponseType  isVoiceResponse_ResponseType `protobuf_oneof:"response_type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VoiceResponse) Reset() {
	*x = VoiceResponse{}
	mi := &file_speech_speech_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VoiceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VoiceResponse) ProtoMessage() {}

func (x *VoiceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VoiceResponse.ProtoReflect.Descriptor instead.
func (*VoiceResponse) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{5}
}

func (x *VoiceResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *VoiceResponse) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *VoiceResponse) GetStatus() *ResponseStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

func (x *VoiceResponse) GetResponseType() isVoiceResponse_ResponseType {
	if x != nil {
		return x.ResponseType
	}
	return nil
}

func (x *VoiceResponse) GetAsrResult() *ASRResult {
	if x != nil {
		if x, ok := x.ResponseType.(*VoiceResponse_AsrResult); ok {
			return x.AsrResult
		}
	}
	return nil
}

func (x *VoiceResponse) GetLlmResult() *LLMResult {
	if x != nil {
		if x, ok := x.ResponseType.(*VoiceResponse_LlmResult); ok {
			return x.LlmResult
		}
	}
	return nil
}

func (x *VoiceResponse) GetTtsResult() *TTSResult {
	if x != nil {
		if x, ok := x.ResponseType.(*VoiceResponse_TtsResult); ok {
			return x.TtsResult
		}
	}
	return nil
}

func (x *VoiceResponse) GetIseResult() *ISEResult {
	if x != nil {
		if x, ok := x.ResponseType.(*VoiceResponse_IseResult); ok {
			return x.IseResult
		}
	}
	return nil
}

func (x *VoiceResponse) GetError() *ErrorResult {
	if x != nil {
		if x, ok := x.ResponseType.(*VoiceResponse_Error); ok {
			return x.Error
		}
	}
	return nil
}

func (x *VoiceResponse) GetStatusResult() *StatusResult {
	if x != nil {
		if x, ok := x.ResponseType.(*VoiceResponse_StatusResult); ok {
			return x.StatusResult
		}
	}
	return nil
}

type isVoiceResponse_ResponseType interface {
	isVoiceResponse_ResponseType()
}

type VoiceResponse_AsrResult struct {
	AsrResult *ASRResult `protobuf:"bytes,4,opt,name=asr_result,json=asrResult,proto3,oneof"`
}

type VoiceResponse_LlmResult struct {
	LlmResult *LLMResult `protobuf:"bytes,5,opt,name=llm_result,json=llmResult,proto3,oneof"`
}

type VoiceResponse_TtsResult struct {
	TtsResult *TTSResult `protobuf:"bytes,6,opt,name=tts_result,json=ttsResult,proto3,oneof"`
}

type VoiceResponse_IseResult struct {
	IseResult *ISEResult `protobuf:"bytes,7,opt,name=ise_result,json=iseResult,proto3,oneof"`
}

type VoiceResponse_Error struct {
	Error *ErrorResult `protobuf:"bytes,8,opt,name=error,proto3,oneof"`
}

type VoiceResponse_StatusResult struct {
	StatusResult *StatusResult `protobuf:"bytes,9,opt,name=status_result,json=statusResult,proto3,oneof"`
}

func (*VoiceResponse_AsrResult) isVoiceResponse_ResponseType() {}

func (*VoiceResponse_LlmResult) isVoiceResponse_ResponseType() {}

func (*VoiceResponse_TtsResult) isVoiceResponse_ResponseType() {}

func (*VoiceResponse_IseResult) isVoiceResponse_ResponseType() {}

func (*VoiceResponse_Error) isVoiceResponse_ResponseType() {}

func (*VoiceResponse_StatusResult) isVoiceResponse_ResponseType() {}

// ASRResult contains speech recognition results
type ASRResult struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Text           string                 `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Confidence     float32                `protobuf:"fixed32,2,opt,name=confidence,proto3" json:"confidence,omitempty"`
	IsFinal        bool                   `protobuf:"varint,3,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
	StartTimeMs    int64                  `protobuf:"varint,4,opt,name=start_time_ms,json=startTimeMs,proto3" json:"start_time_ms,omitempty"`
	EndTimeMs      int64                  `protobuf:"varint,5,opt,name=end_time_ms,json=endTimeMs,proto3" json:"end_time_ms,omitempty"`
	WordAlignments []*WordAlignment       `protobuf:"bytes,6,rep,name=word_alignments,json=wordAlignments,proto3" json:"word_alignments,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ASRResult) Reset() {
	*x = ASRResult{}
	mi := &file_speech_speech_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ASRResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ASRResult) ProtoMessage() {}

func (x *ASRResult) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ASRResult.ProtoReflect.Descriptor instead.
func (*ASRResult) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{6}
}

func (x *ASRResult) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *ASRResult) GetConfidence() float32 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *ASRResult) GetIsFinal() bool {
	if x != nil {
		return x.IsFinal
	}
	return false
}

func (x *ASRResult) GetStartTimeMs() int64 {
	if x != nil {
		return x.StartTimeMs
	}
	return 0
}

func (x *ASRResult) GetEndTimeMs() int64 {
	if x != nil {
		return x.EndTimeMs
	}
	return 0
}

func (x *ASRResult) GetWordAlignments() []*WordAlignment {
	if x != nil {
		return x.WordAlignments
	}
	return nil
}

// WordAlignment provides word-level timing information
type WordAlignment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Word          string                 `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	StartTimeMs   int64                  `protobuf:"varint,2,opt,name=start_time_ms,json=startTimeMs,proto3" json:"start_time_ms,omitempty"`
	EndTimeMs     int64                  `protobuf:"varint,3,opt,name=end_time_ms,json=endTimeMs,proto3" json:"end_time_ms,omitempty"`
	Confidence    float32                `protobuf:"fixed32,4,opt,name=confidence,proto3" json:"confidence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WordAlignment) Reset() {
	*x = WordAlignment{}
	mi := &file_speech_speech_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WordAlignment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WordAlignment) ProtoMessage() {}

func (x *WordAlignment) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WordAlignment.ProtoReflect.Descriptor instead.
func (*WordAlignment) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{7}
}

func (x *WordAlignment) GetWord() string {
	if x != nil {
		return x.Word
	}
	return ""
}

func (x *WordAlignment) GetStartTimeMs() int64 {
	if x != nil {
		return x.StartTimeMs
	}
	return 0
}

func (x *WordAlignment) GetEndTimeMs() int64 {
	if x != nil {
		return x.EndTimeMs
	}
	return 0
}

func (x *WordAlignment) GetConfidence() float32 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

// LLMResult contains language model response
type LLMResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Text          string                 `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	Context       string                 `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
	Confidence    float32                `protobuf:"fixed32,3,opt,name=confidence,proto3" json:"confidence,omitempty"`
	ResultType    LLMResultType          `protobuf:"varint,4,opt,name=result_type,json=resultType,proto3,enum=speech.v1.LLMResultType" json:"result_type,omitempty"`
	Metadata      map[string]string      `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LLMResult) Reset() {
	*x = LLMResult{}
	mi := &file_speech_speech_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LLMResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LLMResult) ProtoMessage() {}

func (x *LLMResult) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LLMResult.ProtoReflect.Descriptor instead.
func (*LLMResult) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{8}
}

func (x *LLMResult) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

func (x *LLMResult) GetContext() string {
	if x != nil {
		return x.Context
	}
	return ""
}

func (x *LLMResult) GetConfidence() float32 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

func (x *LLMResult) GetResultType() LLMResultType {
	if x != nil {
		return x.ResultType
	}
	return LLMResultType_LLM_RESULT_TYPE_UNSPECIFIED
}

func (x *LLMResult) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// TTSResult contains text-to-speech output
type TTSResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	AudioData     []byte                 `protobuf:"bytes,1,opt,name=audio_data,json=audioData,proto3" json:"audio_data,omitempty"`
	Format        *AudioFormat           `protobuf:"bytes,2,opt,name=format,proto3" json:"format,omitempty"`
	DurationMs    int64                  `protobuf:"varint,3,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	IsFinal       bool                   `protobuf:"varint,4,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
	ChunkIndex    int32                  `protobuf:"varint,5,opt,name=chunk_index,json=chunkIndex,proto3" json:"chunk_index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TTSResult) Reset() {
	*x = TTSResult{}
	mi := &file_speech_speech_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TTSResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TTSResult) ProtoMessage() {}

func (x *TTSResult) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TTSResult.ProtoReflect.Descriptor instead.
func (*TTSResult) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{9}
}

func (x *TTSResult) GetAudioData() []byte {
	if x != nil {
		return x.AudioData
	}
	return nil
}

func (x *TTSResult) GetFormat() *AudioFormat {
	if x != nil {
		return x.Format
	}
	return nil
}

func (x *TTSResult) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *TTSResult) GetIsFinal() bool {
	if x != nil {
		return x.IsFinal
	}
	return false
}

func (x *TTSResult) GetChunkIndex() int32 {
	if x != nil {
		return x.ChunkIndex
	}
	return 0
}

// ISEResult contains speech evaluation results
type ISEResult struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	OverallScore      float32                `protobuf:"fixed32,1,opt,name=overall_score,json=overallScore,proto3" json:"overall_score,omitempty"`                // Overall pronunciation score (0-100)
	AccuracyScore     float32                `protobuf:"fixed32,2,opt,name=accuracy_score,json=accuracyScore,proto3" json:"accuracy_score,omitempty"`             // Accuracy score (0-100)
	FluencyScore      float32                `protobuf:"fixed32,3,opt,name=fluency_score,json=fluencyScore,proto3" json:"fluency_score,omitempty"`                // Fluency score (0-100)
	CompletenessScore float32                `protobuf:"fixed32,4,opt,name=completeness_score,json=completenessScore,proto3" json:"completeness_score,omitempty"` // Completeness score (0-100)
	WordScores        []*WordScore           `protobuf:"bytes,5,rep,name=word_scores,json=wordScores,proto3" json:"word_scores,omitempty"`                        // Word-level scores
	PhoneScores       []*PhoneScore          `protobuf:"bytes,6,rep,name=phone_scores,json=phoneScores,proto3" json:"phone_scores,omitempty"`                     // Phoneme-level scores
	SentenceScores    []*SentenceScore       `protobuf:"bytes,7,rep,name=sentence_scores,json=sentenceScores,proto3" json:"sentence_scores,omitempty"`            // Sentence-level scores
	IsFinal           bool                   `protobuf:"varint,8,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
	ReferenceText     string                 `protobuf:"bytes,9,opt,name=reference_text,json=referenceText,proto3" json:"reference_text,omitempty"` // Original text that was evaluated against
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ISEResult) Reset() {
	*x = ISEResult{}
	mi := &file_speech_speech_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ISEResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ISEResult) ProtoMessage() {}

func (x *ISEResult) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ISEResult.ProtoReflect.Descriptor instead.
func (*ISEResult) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{10}
}

func (x *ISEResult) GetOverallScore() float32 {
	if x != nil {
		return x.OverallScore
	}
	return 0
}

func (x *ISEResult) GetAccuracyScore() float32 {
	if x != nil {
		return x.AccuracyScore
	}
	return 0
}

func (x *ISEResult) GetFluencyScore() float32 {
	if x != nil {
		return x.FluencyScore
	}
	return 0
}

func (x *ISEResult) GetCompletenessScore() float32 {
	if x != nil {
		return x.CompletenessScore
	}
	return 0
}

func (x *ISEResult) GetWordScores() []*WordScore {
	if x != nil {
		return x.WordScores
	}
	return nil
}

func (x *ISEResult) GetPhoneScores() []*PhoneScore {
	if x != nil {
		return x.PhoneScores
	}
	return nil
}

func (x *ISEResult) GetSentenceScores() []*SentenceScore {
	if x != nil {
		return x.SentenceScores
	}
	return nil
}

func (x *ISEResult) GetIsFinal() bool {
	if x != nil {
		return x.IsFinal
	}
	return false
}

func (x *ISEResult) GetReferenceText() string {
	if x != nil {
		return x.ReferenceText
	}
	return ""
}

// WordScore represents word-level pronunciation evaluation
type WordScore struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Word          string                 `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
	Score         float32                `protobuf:"fixed32,2,opt,name=score,proto3" json:"score,omitempty"`
	StartTime     int64                  `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"` // milliseconds
	EndTime       int64                  `protobuf:"varint,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`       // milliseconds
	IsCorrect     bool                   `protobuf:"varint,5,opt,name=is_correct,json=isCorrect,proto3" json:"is_correct,omitempty"`
	Confidence    float32                `protobuf:"fixed32,6,opt,name=confidence,proto3" json:"confidence,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WordScore) Reset() {
	*x = WordScore{}
	mi := &file_speech_speech_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WordScore) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WordScore) ProtoMessage() {}

func (x *WordScore) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WordScore.ProtoReflect.Descriptor instead.
func (*WordScore) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{11}
}

func (x *WordScore) GetWord() string {
	if x != nil {
		return x.Word
	}
	return ""
}

func (x *WordScore) GetScore() float32 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *WordScore) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *WordScore) GetEndTime() int64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *WordScore) GetIsCorrect() bool {
	if x != nil {
		return x.IsCorrect
	}
	return false
}

func (x *WordScore) GetConfidence() float32 {
	if x != nil {
		return x.Confidence
	}
	return 0
}

// PhoneScore represents phoneme-level pronunciation evaluation
type PhoneScore struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Phone         string                 `protobuf:"bytes,1,opt,name=phone,proto3" json:"phone,omitempty"` // Phoneme symbol (e.g., /ə/, /t/, /h/)
	Score         float32                `protobuf:"fixed32,2,opt,name=score,proto3" json:"score,omitempty"`
	StartTime     int64                  `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"` // milliseconds
	EndTime       int64                  `protobuf:"varint,4,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`       // milliseconds
	IsCorrect     bool                   `protobuf:"varint,5,opt,name=is_correct,json=isCorrect,proto3" json:"is_correct,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PhoneScore) Reset() {
	*x = PhoneScore{}
	mi := &file_speech_speech_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PhoneScore) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PhoneScore) ProtoMessage() {}

func (x *PhoneScore) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PhoneScore.ProtoReflect.Descriptor instead.
func (*PhoneScore) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{12}
}

func (x *PhoneScore) GetPhone() string {
	if x != nil {
		return x.Phone
	}
	return ""
}

func (x *PhoneScore) GetScore() float32 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *PhoneScore) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *PhoneScore) GetEndTime() int64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *PhoneScore) GetIsCorrect() bool {
	if x != nil {
		return x.IsCorrect
	}
	return false
}

// SentenceScore represents sentence-level pronunciation evaluation
type SentenceScore struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Sentence      string                 `protobuf:"bytes,1,opt,name=sentence,proto3" json:"sentence,omitempty"`
	Score         float32                `protobuf:"fixed32,2,opt,name=score,proto3" json:"score,omitempty"`
	AccuracyScore float32                `protobuf:"fixed32,3,opt,name=accuracy_score,json=accuracyScore,proto3" json:"accuracy_score,omitempty"`
	FluencyScore  float32                `protobuf:"fixed32,4,opt,name=fluency_score,json=fluencyScore,proto3" json:"fluency_score,omitempty"`
	TotalWords    int32                  `protobuf:"varint,5,opt,name=total_words,json=totalWords,proto3" json:"total_words,omitempty"`
	CorrectWords  int32                  `protobuf:"varint,6,opt,name=correct_words,json=correctWords,proto3" json:"correct_words,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SentenceScore) Reset() {
	*x = SentenceScore{}
	mi := &file_speech_speech_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SentenceScore) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SentenceScore) ProtoMessage() {}

func (x *SentenceScore) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SentenceScore.ProtoReflect.Descriptor instead.
func (*SentenceScore) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{13}
}

func (x *SentenceScore) GetSentence() string {
	if x != nil {
		return x.Sentence
	}
	return ""
}

func (x *SentenceScore) GetScore() float32 {
	if x != nil {
		return x.Score
	}
	return 0
}

func (x *SentenceScore) GetAccuracyScore() float32 {
	if x != nil {
		return x.AccuracyScore
	}
	return 0
}

func (x *SentenceScore) GetFluencyScore() float32 {
	if x != nil {
		return x.FluencyScore
	}
	return 0
}

func (x *SentenceScore) GetTotalWords() int32 {
	if x != nil {
		return x.TotalWords
	}
	return 0
}

func (x *SentenceScore) GetCorrectWords() int32 {
	if x != nil {
		return x.CorrectWords
	}
	return 0
}

// ErrorResult contains error information
type ErrorResult struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Code          ErrorCode              `protobuf:"varint,1,opt,name=code,proto3,enum=speech.v1.ErrorCode" json:"code,omitempty"`
	Message       string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Details       string                 `protobuf:"bytes,3,opt,name=details,proto3" json:"details,omitempty"`
	Retryable     bool                   `protobuf:"varint,4,opt,name=retryable,proto3" json:"retryable,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ErrorResult) Reset() {
	*x = ErrorResult{}
	mi := &file_speech_speech_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ErrorResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ErrorResult) ProtoMessage() {}

func (x *ErrorResult) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ErrorResult.ProtoReflect.Descriptor instead.
func (*ErrorResult) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{14}
}

func (x *ErrorResult) GetCode() ErrorCode {
	if x != nil {
		return x.Code
	}
	return ErrorCode_ERROR_CODE_UNSPECIFIED
}

func (x *ErrorResult) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *ErrorResult) GetDetails() string {
	if x != nil {
		return x.Details
	}
	return ""
}

func (x *ErrorResult) GetRetryable() bool {
	if x != nil {
		return x.Retryable
	}
	return false
}

// StatusResult contains status updates
type StatusResult struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	ProcessingStatus ProcessingStatus       `protobuf:"varint,1,opt,name=processing_status,json=processingStatus,proto3,enum=speech.v1.ProcessingStatus" json:"processing_status,omitempty"`
	Message          string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	Metadata         map[string]string      `protobuf:"bytes,3,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *StatusResult) Reset() {
	*x = StatusResult{}
	mi := &file_speech_speech_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusResult) ProtoMessage() {}

func (x *StatusResult) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusResult.ProtoReflect.Descriptor instead.
func (*StatusResult) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{15}
}

func (x *StatusResult) GetProcessingStatus() ProcessingStatus {
	if x != nil {
		return x.ProcessingStatus
	}
	return ProcessingStatus_PROCESSING_STATUS_UNSPECIFIED
}

func (x *StatusResult) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *StatusResult) GetMetadata() map[string]string {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// ResponseStatus indicates the overall status of the response
type ResponseStatus struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	Success          bool                   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Message          string                 `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	ProcessingTimeMs int64                  `protobuf:"varint,3,opt,name=processing_time_ms,json=processingTimeMs,proto3" json:"processing_time_ms,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ResponseStatus) Reset() {
	*x = ResponseStatus{}
	mi := &file_speech_speech_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResponseStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResponseStatus) ProtoMessage() {}

func (x *ResponseStatus) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResponseStatus.ProtoReflect.Descriptor instead.
func (*ResponseStatus) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{16}
}

func (x *ResponseStatus) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ResponseStatus) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *ResponseStatus) GetProcessingTimeMs() int64 {
	if x != nil {
		return x.ProcessingTimeMs
	}
	return 0
}

// Health check messages
type HealthCheckRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Service       string                 `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckRequest) Reset() {
	*x = HealthCheckRequest{}
	mi := &file_speech_speech_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckRequest) ProtoMessage() {}

func (x *HealthCheckRequest) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckRequest.ProtoReflect.Descriptor instead.
func (*HealthCheckRequest) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{17}
}

func (x *HealthCheckRequest) GetService() string {
	if x != nil {
		return x.Service
	}
	return ""
}

type HealthCheckResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Status        HealthStatus           `protobuf:"varint,1,opt,name=status,proto3,enum=speech.v1.HealthStatus" json:"status,omitempty"`
	Details       map[string]string      `protobuf:"bytes,2,rep,name=details,proto3" json:"details,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HealthCheckResponse) Reset() {
	*x = HealthCheckResponse{}
	mi := &file_speech_speech_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HealthCheckResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HealthCheckResponse) ProtoMessage() {}

func (x *HealthCheckResponse) ProtoReflect() protoreflect.Message {
	mi := &file_speech_speech_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HealthCheckResponse.ProtoReflect.Descriptor instead.
func (*HealthCheckResponse) Descriptor() ([]byte, []int) {
	return file_speech_speech_proto_rawDescGZIP(), []int{18}
}

func (x *HealthCheckResponse) GetStatus() HealthStatus {
	if x != nil {
		return x.Status
	}
	return HealthStatus_HEALTH_STATUS_UNSPECIFIED
}

func (x *HealthCheckResponse) GetDetails() map[string]string {
	if x != nil {
		return x.Details
	}
	return nil
}

var File_speech_speech_proto protoreflect.FileDescriptor

const file_speech_speech_proto_rawDesc = "" +
	"\n" +
	"\x13speech/speech.proto\x12\tspeech.v1\"\xc9\x01\n" +
	"\fVoiceRequest\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x125\n" +
	"\n" +
	"audio_data\x18\x03 \x01(\v2\x14.speech.v1.AudioDataH\x00R\taudioData\x125\n" +
	"\acontrol\x18\x04 \x01(\v2\x19.speech.v1.ControlMessageH\x00R\acontrolB\x0e\n" +
	"\frequest_type\"\x85\x01\n" +
	"\tAudioData\x12\x12\n" +
	"\x04data\x18\x01 \x01(\fR\x04data\x12.\n" +
	"\x06format\x18\x02 \x01(\v2\x16.speech.v1.AudioFormatR\x06format\x124\n" +
	"\bmetadata\x18\x03 \x01(\v2\x18.speech.v1.AudioMetadataR\bmetadata\"}\n" +
	"\vAudioFormat\x12\x14\n" +
	"\x05codec\x18\x01 \x01(\tR\x05codec\x12\x1f\n" +
	"\vsample_rate\x18\x02 \x01(\x05R\n" +
	"sampleRate\x12\x1a\n" +
	"\bchannels\x18\x03 \x01(\x05R\bchannels\x12\x1b\n" +
	"\tbit_depth\x18\x04 \x01(\x05R\bbitDepth\"l\n" +
	"\rAudioMetadata\x12\x1f\n" +
	"\vduration_ms\x18\x01 \x01(\x03R\n" +
	"durationMs\x12\x1f\n" +
	"\vchunk_index\x18\x02 \x01(\x05R\n" +
	"chunkIndex\x12\x19\n" +
	"\bis_final\x18\x03 \x01(\bR\aisFinal\"\xbc\x01\n" +
	"\x0eControlMessage\x120\n" +
	"\x06action\x18\x01 \x01(\x0e2\x18.speech.v1.ControlActionR\x06action\x12=\n" +
	"\x06params\x18\x02 \x03(\v2%.speech.v1.ControlMessage.ParamsEntryR\x06params\x1a9\n" +
	"\vParamsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xdc\x03\n" +
	"\rVoiceResponse\x12\x1d\n" +
	"\n" +
	"session_id\x18\x01 \x01(\tR\tsessionId\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x121\n" +
	"\x06status\x18\x03 \x01(\v2\x19.speech.v1.ResponseStatusR\x06status\x125\n" +
	"\n" +
	"asr_result\x18\x04 \x01(\v2\x14.speech.v1.ASRResultH\x00R\tasrResult\x125\n" +
	"\n" +
	"llm_result\x18\x05 \x01(\v2\x14.speech.v1.LLMResultH\x00R\tllmResult\x125\n" +
	"\n" +
	"tts_result\x18\x06 \x01(\v2\x14.speech.v1.TTSResultH\x00R\tttsResult\x125\n" +
	"\n" +
	"ise_result\x18\a \x01(\v2\x14.speech.v1.ISEResultH\x00R\tiseResult\x12.\n" +
	"\x05error\x18\b \x01(\v2\x16.speech.v1.ErrorResultH\x00R\x05error\x12>\n" +
	"\rstatus_result\x18\t \x01(\v2\x17.speech.v1.StatusResultH\x00R\fstatusResultB\x0f\n" +
	"\rresponse_type\"\xe1\x01\n" +
	"\tASRResult\x12\x12\n" +
	"\x04text\x18\x01 \x01(\tR\x04text\x12\x1e\n" +
	"\n" +
	"confidence\x18\x02 \x01(\x02R\n" +
	"confidence\x12\x19\n" +
	"\bis_final\x18\x03 \x01(\bR\aisFinal\x12\"\n" +
	"\rstart_time_ms\x18\x04 \x01(\x03R\vstartTimeMs\x12\x1e\n" +
	"\vend_time_ms\x18\x05 \x01(\x03R\tendTimeMs\x12A\n" +
	"\x0fword_alignments\x18\x06 \x03(\v2\x18.speech.v1.WordAlignmentR\x0ewordAlignments\"\x87\x01\n" +
	"\rWordAlignment\x12\x12\n" +
	"\x04word\x18\x01 \x01(\tR\x04word\x12\"\n" +
	"\rstart_time_ms\x18\x02 \x01(\x03R\vstartTimeMs\x12\x1e\n" +
	"\vend_time_ms\x18\x03 \x01(\x03R\tendTimeMs\x12\x1e\n" +
	"\n" +
	"confidence\x18\x04 \x01(\x02R\n" +
	"confidence\"\x91\x02\n" +
	"\tLLMResult\x12\x12\n" +
	"\x04text\x18\x01 \x01(\tR\x04text\x12\x18\n" +
	"\acontext\x18\x02 \x01(\tR\acontext\x12\x1e\n" +
	"\n" +
	"confidence\x18\x03 \x01(\x02R\n" +
	"confidence\x129\n" +
	"\vresult_type\x18\x04 \x01(\x0e2\x18.speech.v1.LLMResultTypeR\n" +
	"resultType\x12>\n" +
	"\bmetadata\x18\x05 \x03(\v2\".speech.v1.LLMResult.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb7\x01\n" +
	"\tTTSResult\x12\x1d\n" +
	"\n" +
	"audio_data\x18\x01 \x01(\fR\taudioData\x12.\n" +
	"\x06format\x18\x02 \x01(\v2\x16.speech.v1.AudioFormatR\x06format\x12\x1f\n" +
	"\vduration_ms\x18\x03 \x01(\x03R\n" +
	"durationMs\x12\x19\n" +
	"\bis_final\x18\x04 \x01(\bR\aisFinal\x12\x1f\n" +
	"\vchunk_index\x18\x05 \x01(\x05R\n" +
	"chunkIndex\"\xa1\x03\n" +
	"\tISEResult\x12#\n" +
	"\roverall_score\x18\x01 \x01(\x02R\foverallScore\x12%\n" +
	"\x0eaccuracy_score\x18\x02 \x01(\x02R\raccuracyScore\x12#\n" +
	"\rfluency_score\x18\x03 \x01(\x02R\ffluencyScore\x12-\n" +
	"\x12completeness_score\x18\x04 \x01(\x02R\x11completenessScore\x125\n" +
	"\vword_scores\x18\x05 \x03(\v2\x14.speech.v1.WordScoreR\n" +
	"wordScores\x128\n" +
	"\fphone_scores\x18\x06 \x03(\v2\x15.speech.v1.PhoneScoreR\vphoneScores\x12A\n" +
	"\x0fsentence_scores\x18\a \x03(\v2\x18.speech.v1.SentenceScoreR\x0esentenceScores\x12\x19\n" +
	"\bis_final\x18\b \x01(\bR\aisFinal\x12%\n" +
	"\x0ereference_text\x18\t \x01(\tR\rreferenceText\"\xae\x01\n" +
	"\tWordScore\x12\x12\n" +
	"\x04word\x18\x01 \x01(\tR\x04word\x12\x14\n" +
	"\x05score\x18\x02 \x01(\x02R\x05score\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x04 \x01(\x03R\aendTime\x12\x1d\n" +
	"\n" +
	"is_correct\x18\x05 \x01(\bR\tisCorrect\x12\x1e\n" +
	"\n" +
	"confidence\x18\x06 \x01(\x02R\n" +
	"confidence\"\x91\x01\n" +
	"\n" +
	"PhoneScore\x12\x14\n" +
	"\x05phone\x18\x01 \x01(\tR\x05phone\x12\x14\n" +
	"\x05score\x18\x02 \x01(\x02R\x05score\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x04 \x01(\x03R\aendTime\x12\x1d\n" +
	"\n" +
	"is_correct\x18\x05 \x01(\bR\tisCorrect\"\xd3\x01\n" +
	"\rSentenceScore\x12\x1a\n" +
	"\bsentence\x18\x01 \x01(\tR\bsentence\x12\x14\n" +
	"\x05score\x18\x02 \x01(\x02R\x05score\x12%\n" +
	"\x0eaccuracy_score\x18\x03 \x01(\x02R\raccuracyScore\x12#\n" +
	"\rfluency_score\x18\x04 \x01(\x02R\ffluencyScore\x12\x1f\n" +
	"\vtotal_words\x18\x05 \x01(\x05R\n" +
	"totalWords\x12#\n" +
	"\rcorrect_words\x18\x06 \x01(\x05R\fcorrectWords\"\x89\x01\n" +
	"\vErrorResult\x12(\n" +
	"\x04code\x18\x01 \x01(\x0e2\x14.speech.v1.ErrorCodeR\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12\x18\n" +
	"\adetails\x18\x03 \x01(\tR\adetails\x12\x1c\n" +
	"\tretryable\x18\x04 \x01(\bR\tretryable\"\xf2\x01\n" +
	"\fStatusResult\x12H\n" +
	"\x11processing_status\x18\x01 \x01(\x0e2\x1b.speech.v1.ProcessingStatusR\x10processingStatus\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12A\n" +
	"\bmetadata\x18\x03 \x03(\v2%.speech.v1.StatusResult.MetadataEntryR\bmetadata\x1a;\n" +
	"\rMetadataEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"r\n" +
	"\x0eResponseStatus\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\x12,\n" +
	"\x12processing_time_ms\x18\x03 \x01(\x03R\x10processingTimeMs\".\n" +
	"\x12HealthCheckRequest\x12\x18\n" +
	"\aservice\x18\x01 \x01(\tR\aservice\"\xc9\x01\n" +
	"\x13HealthCheckResponse\x12/\n" +
	"\x06status\x18\x01 \x01(\x0e2\x17.speech.v1.HealthStatusR\x06status\x12E\n" +
	"\adetails\x18\x02 \x03(\v2+.speech.v1.HealthCheckResponse.DetailsEntryR\adetails\x1a:\n" +
	"\fDetailsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01*\xdb\x01\n" +
	"\rControlAction\x12\x1e\n" +
	"\x1aCONTROL_ACTION_UNSPECIFIED\x10\x00\x12\"\n" +
	"\x1eCONTROL_ACTION_START_RECORDING\x10\x01\x12!\n" +
	"\x1dCONTROL_ACTION_STOP_RECORDING\x10\x02\x12\x1e\n" +
	"\x1aCONTROL_ACTION_END_SESSION\x10\x03\x12 \n" +
	"\x1cCONTROL_ACTION_PAUSE_SESSION\x10\x04\x12!\n" +
	"\x1dCONTROL_ACTION_RESUME_SESSION\x10\x05*\xab\x01\n" +
	"\rLLMResultType\x12\x1f\n" +
	"\x1bLLM_RESULT_TYPE_UNSPECIFIED\x10\x00\x12\x1c\n" +
	"\x18LLM_RESULT_TYPE_RESPONSE\x10\x01\x12\x1e\n" +
	"\x1aLLM_RESULT_TYPE_CORRECTION\x10\x02\x12\x1e\n" +
	"\x1aLLM_RESULT_TYPE_SUGGESTION\x10\x03\x12\x1b\n" +
	"\x17LLM_RESULT_TYPE_STARTER\x10\x04*\xa3\x02\n" +
	"\tErrorCode\x12\x1a\n" +
	"\x16ERROR_CODE_UNSPECIFIED\x10\x00\x12\x1e\n" +
	"\x1aERROR_CODE_INVALID_REQUEST\x10\x01\x12&\n" +
	"\"ERROR_CODE_AUDIO_PROCESSING_FAILED\x10\x02\x12\x19\n" +
	"\x15ERROR_CODE_ASR_FAILED\x10\x03\x12\x19\n" +
	"\x15ERROR_CODE_LLM_FAILED\x10\x04\x12\x19\n" +
	"\x15ERROR_CODE_TTS_FAILED\x10\x05\x12 \n" +
	"\x1cERROR_CODE_SESSION_NOT_FOUND\x10\x06\x12\"\n" +
	"\x1eERROR_CODE_SERVICE_UNAVAILABLE\x10\a\x12\x1b\n" +
	"\x17ERROR_CODE_RATE_LIMITED\x10\b*\xb5\x01\n" +
	"\x10ProcessingStatus\x12!\n" +
	"\x1dPROCESSING_STATUS_UNSPECIFIED\x10\x00\x12\x1d\n" +
	"\x19PROCESSING_STATUS_STARTED\x10\x01\x12 \n" +
	"\x1cPROCESSING_STATUS_PROCESSING\x10\x02\x12\x1f\n" +
	"\x1bPROCESSING_STATUS_COMPLETED\x10\x03\x12\x1c\n" +
	"\x18PROCESSING_STATUS_FAILED\x10\x04*\x8a\x01\n" +
	"\fHealthStatus\x12\x1d\n" +
	"\x19HEALTH_STATUS_UNSPECIFIED\x10\x00\x12\x19\n" +
	"\x15HEALTH_STATUS_SERVING\x10\x01\x12\x1d\n" +
	"\x19HEALTH_STATUS_NOT_SERVING\x10\x02\x12!\n" +
	"\x1dHEALTH_STATUS_SERVICE_UNKNOWN\x10\x032\xb0\x01\n" +
	"\rSpeechService\x12Q\n" +
	"\x18ProcessVoiceConversation\x12\x17.speech.v1.VoiceRequest\x1a\x18.speech.v1.VoiceResponse(\x010\x01\x12L\n" +
	"\vHealthCheck\x12\x1d.speech.v1.HealthCheckRequest\x1a\x1e.speech.v1.HealthCheckResponseB>Z<github.com/ai-tutor-monorepo/shared/proto/speech/v1;speechv1b\x06proto3"

var (
	file_speech_speech_proto_rawDescOnce sync.Once
	file_speech_speech_proto_rawDescData []byte
)

func file_speech_speech_proto_rawDescGZIP() []byte {
	file_speech_speech_proto_rawDescOnce.Do(func() {
		file_speech_speech_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_speech_speech_proto_rawDesc), len(file_speech_speech_proto_rawDesc)))
	})
	return file_speech_speech_proto_rawDescData
}

var file_speech_speech_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_speech_speech_proto_msgTypes = make([]protoimpl.MessageInfo, 23)
var file_speech_speech_proto_goTypes = []any{
	(ControlAction)(0),          // 0: speech.v1.ControlAction
	(LLMResultType)(0),          // 1: speech.v1.LLMResultType
	(ErrorCode)(0),              // 2: speech.v1.ErrorCode
	(ProcessingStatus)(0),       // 3: speech.v1.ProcessingStatus
	(HealthStatus)(0),           // 4: speech.v1.HealthStatus
	(*VoiceRequest)(nil),        // 5: speech.v1.VoiceRequest
	(*AudioData)(nil),           // 6: speech.v1.AudioData
	(*AudioFormat)(nil),         // 7: speech.v1.AudioFormat
	(*AudioMetadata)(nil),       // 8: speech.v1.AudioMetadata
	(*ControlMessage)(nil),      // 9: speech.v1.ControlMessage
	(*VoiceResponse)(nil),       // 10: speech.v1.VoiceResponse
	(*ASRResult)(nil),           // 11: speech.v1.ASRResult
	(*WordAlignment)(nil),       // 12: speech.v1.WordAlignment
	(*LLMResult)(nil),           // 13: speech.v1.LLMResult
	(*TTSResult)(nil),           // 14: speech.v1.TTSResult
	(*ISEResult)(nil),           // 15: speech.v1.ISEResult
	(*WordScore)(nil),           // 16: speech.v1.WordScore
	(*PhoneScore)(nil),          // 17: speech.v1.PhoneScore
	(*SentenceScore)(nil),       // 18: speech.v1.SentenceScore
	(*ErrorResult)(nil),         // 19: speech.v1.ErrorResult
	(*StatusResult)(nil),        // 20: speech.v1.StatusResult
	(*ResponseStatus)(nil),      // 21: speech.v1.ResponseStatus
	(*HealthCheckRequest)(nil),  // 22: speech.v1.HealthCheckRequest
	(*HealthCheckResponse)(nil), // 23: speech.v1.HealthCheckResponse
	nil,                         // 24: speech.v1.ControlMessage.ParamsEntry
	nil,                         // 25: speech.v1.LLMResult.MetadataEntry
	nil,                         // 26: speech.v1.StatusResult.MetadataEntry
	nil,                         // 27: speech.v1.HealthCheckResponse.DetailsEntry
}
var file_speech_speech_proto_depIdxs = []int32{
	6,  // 0: speech.v1.VoiceRequest.audio_data:type_name -> speech.v1.AudioData
	9,  // 1: speech.v1.VoiceRequest.control:type_name -> speech.v1.ControlMessage
	7,  // 2: speech.v1.AudioData.format:type_name -> speech.v1.AudioFormat
	8,  // 3: speech.v1.AudioData.metadata:type_name -> speech.v1.AudioMetadata
	0,  // 4: speech.v1.ControlMessage.action:type_name -> speech.v1.ControlAction
	24, // 5: speech.v1.ControlMessage.params:type_name -> speech.v1.ControlMessage.ParamsEntry
	21, // 6: speech.v1.VoiceResponse.status:type_name -> speech.v1.ResponseStatus
	11, // 7: speech.v1.VoiceResponse.asr_result:type_name -> speech.v1.ASRResult
	13, // 8: speech.v1.VoiceResponse.llm_result:type_name -> speech.v1.LLMResult
	14, // 9: speech.v1.VoiceResponse.tts_result:type_name -> speech.v1.TTSResult
	15, // 10: speech.v1.VoiceResponse.ise_result:type_name -> speech.v1.ISEResult
	19, // 11: speech.v1.VoiceResponse.error:type_name -> speech.v1.ErrorResult
	20, // 12: speech.v1.VoiceResponse.status_result:type_name -> speech.v1.StatusResult
	12, // 13: speech.v1.ASRResult.word_alignments:type_name -> speech.v1.WordAlignment
	1,  // 14: speech.v1.LLMResult.result_type:type_name -> speech.v1.LLMResultType
	25, // 15: speech.v1.LLMResult.metadata:type_name -> speech.v1.LLMResult.MetadataEntry
	7,  // 16: speech.v1.TTSResult.format:type_name -> speech.v1.AudioFormat
	16, // 17: speech.v1.ISEResult.word_scores:type_name -> speech.v1.WordScore
	17, // 18: speech.v1.ISEResult.phone_scores:type_name -> speech.v1.PhoneScore
	18, // 19: speech.v1.ISEResult.sentence_scores:type_name -> speech.v1.SentenceScore
	2,  // 20: speech.v1.ErrorResult.code:type_name -> speech.v1.ErrorCode
	3,  // 21: speech.v1.StatusResult.processing_status:type_name -> speech.v1.ProcessingStatus
	26, // 22: speech.v1.StatusResult.metadata:type_name -> speech.v1.StatusResult.MetadataEntry
	4,  // 23: speech.v1.HealthCheckResponse.status:type_name -> speech.v1.HealthStatus
	27, // 24: speech.v1.HealthCheckResponse.details:type_name -> speech.v1.HealthCheckResponse.DetailsEntry
	5,  // 25: speech.v1.SpeechService.ProcessVoiceConversation:input_type -> speech.v1.VoiceRequest
	22, // 26: speech.v1.SpeechService.HealthCheck:input_type -> speech.v1.HealthCheckRequest
	10, // 27: speech.v1.SpeechService.ProcessVoiceConversation:output_type -> speech.v1.VoiceResponse
	23, // 28: speech.v1.SpeechService.HealthCheck:output_type -> speech.v1.HealthCheckResponse
	27, // [27:29] is the sub-list for method output_type
	25, // [25:27] is the sub-list for method input_type
	25, // [25:25] is the sub-list for extension type_name
	25, // [25:25] is the sub-list for extension extendee
	0,  // [0:25] is the sub-list for field type_name
}

func init() { file_speech_speech_proto_init() }
func file_speech_speech_proto_init() {
	if File_speech_speech_proto != nil {
		return
	}
	file_speech_speech_proto_msgTypes[0].OneofWrappers = []any{
		(*VoiceRequest_AudioData)(nil),
		(*VoiceRequest_Control)(nil),
	}
	file_speech_speech_proto_msgTypes[5].OneofWrappers = []any{
		(*VoiceResponse_AsrResult)(nil),
		(*VoiceResponse_LlmResult)(nil),
		(*VoiceResponse_TtsResult)(nil),
		(*VoiceResponse_IseResult)(nil),
		(*VoiceResponse_Error)(nil),
		(*VoiceResponse_StatusResult)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_speech_speech_proto_rawDesc), len(file_speech_speech_proto_rawDesc)),
			NumEnums:      5,
			NumMessages:   23,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_speech_speech_proto_goTypes,
		DependencyIndexes: file_speech_speech_proto_depIdxs,
		EnumInfos:         file_speech_speech_proto_enumTypes,
		MessageInfos:      file_speech_speech_proto_msgTypes,
	}.Build()
	File_speech_speech_proto = out.File
	file_speech_speech_proto_goTypes = nil
	file_speech_speech_proto_depIdxs = nil
}
